- ruleID: ensure_https_loadbalancers_encrypted_with_tls_aws
  effort: 1
  category: optional
  message: ""
  when:
    k8s-resource.rego_module:
        module: |-
            package policy

            import data.kubernetes.api.client

            # deny LoadBalancer services that are configured for ssl connection (port: 443), but don't have TLS certificate set.
            deny[msga] {

            	wl_kind := "Service"
            	wl_type := "LoadBalancer"
            	wl_required_annotation := "service.beta.kubernetes.io/aws-load-balancer-ssl-cert"

            	# filterring LoadBalancers
            	wl := 	input[_]
            	wl.kind == wl_kind
            	wl.spec.type == wl_type

            	#  filterring loadbalancers with port 443.
            	wl.spec.ports[_].port == 443

            	# filterring annotations without ssl cert confgiured.
            	annotations := object.get(wl, ["metadata", "annotations"], [])
            	ssl_cert_annotations := [annotations[i] | annotation = i; startswith(i, wl_required_annotation)]
            	count(ssl_cert_annotations) == 0

            	# prepare message data.
            	alert_message :=  sprintf("LoadBalancer '%v' has no TLS configured", [wl.metadata.name])
            	failed_paths := []
            	fixed_paths := [{"path": sprintf("metadata.annotations['%v']", [wl_required_annotation]), "value": "AWS_LOADBALANCER_SSL_CERT"}]

            	msga := {
            		"alertMessage": alert_message,
            		"packagename": "policy",
            		"alertScore": 7,
            		"failedPaths": failed_paths,
            		"fixPaths": fixed_paths,
            		"alertObject": {
            			"k8sApiObjects": [],
                        "externalObjects": wl
            		}
            	}
            }


            incidents[msg] {
              violation := deny[_]
              apiObjects := object.get(violation.alertObject, "k8sApiObjects", false)
              item := apiObjects[_]
              msg := {
            	  "apiVersion": item.apiVersion,
            		"namespace": item.metadata.namespace,
            		"kind": item.kind,
            		"name": item.metadata.name,
              }
            }

            incidents[msg] {
              violation := deny[_]
              item := object.get(violation.alertObject, "externalObjects", false)
              msg := {
            	  "apiVersion": item.apiVersion,
            		"namespace": item.metadata.namespace,
            		"kind": item.kind,
            		"name": item.metadata.name,
              }
            }
