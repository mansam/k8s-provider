- ruleID: system_authenticated_allowed_to_take_over_cluster
  effort: 1
  category: optional
  message: Fails in system:authenticated user has cluster takeover rbac permissions (is bound by a RoleBinding/ClusterRoleBinding)
  when:
    k8s-resource.rego_module:
        module: |-
            package policy

            import future.keywords.in

            deny[msga] {
                subjectVector := input[_]

            	rolebinding := subjectVector.relatedObjects[j]
            	endswith(rolebinding.kind, "Binding")


                subject := rolebinding.subjects[k]
                # Check if the subject is gourp
                subject.kind == "Group"
                # Check if the subject is system:authenticated
                subject.name == "system:authenticated"


                # Find the bound roles
            	role := subjectVector.relatedObjects[i]
            	endswith(role.kind, "Role")

                # Check if the role and rolebinding bound
                is_same_role_and_binding(role, rolebinding)


                # Check if the role has access to workloads, exec, attach, portforward
            	rule := role.rules[p]
                rule.resources[l] in ["*","pods", "pods/exec", "pods/attach", "pods/portforward","deployments","statefulset","daemonset","jobs","cronjobs","nodes","secrets"]

            	finalpath := array.concat([""], [
            		sprintf("relatedObjects[%d].subjects[%d]", [j, k]),
            		sprintf("relatedObjects[%d].roleRef.name", [i]),
            	])

            	msga := {
            		"alertMessage": "system:authenticated has sensitive roles",
            		"alertScore": 5,
            		"reviewPaths": finalpath,
            		"failedPaths": finalpath,
            		"fixPaths": [],
            		"packagename": "policy",
            		"alertObject": {
            			"k8sApiObjects": [],
                        "externalObjects" : subjectVector
            		},
            	}
            }

            is_same_role_and_binding(role, rolebinding) {
                rolebinding.kind == "RoleBinding"
                role.kind == "Role"
                rolebinding.metadata.namespace == role.metadata.namespace
                rolebinding.roleRef.name == role.metadata.name
                rolebinding.roleRef.kind == role.kind
                startswith(role.apiVersion, rolebinding.roleRef.apiGroup)
            }

            is_same_role_and_binding(role, rolebinding) {
                rolebinding.kind == "ClusterRoleBinding"
                role.kind == "ClusterRole"
                rolebinding.roleRef.name == role.metadata.name
                rolebinding.roleRef.kind == role.kind
                startswith(role.apiVersion, rolebinding.roleRef.apiGroup)
            }
            incidents[msg] {
              violation := deny[_]
              apiObjects := object.get(violation.alertObject, "k8sApiObjects", false)
              item := apiObjects[_]
              msg := {
            	  "apiVersion": item.apiVersion,
            		"namespace": item.metadata.namespace,
            		"kind": item.kind,
            		"name": item.metadata.name,
              }
            }

            incidents[msg] {
              violation := deny[_]
              item := object.get(violation.alertObject, "externalObjects", false)
              msg := {
            	  "apiVersion": item.apiVersion,
            		"namespace": item.metadata.namespace,
            		"kind": item.kind,
            		"name": item.metadata.name,
              }
            }
