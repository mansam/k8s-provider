- ruleID: exposure_to_internet
  effort: 1
  category: optional
  message: fails in case the running workload has binded Service or Ingress that are exposing it on Internet.
  labels:
    - eks
    - kubernetes
    - kubescape
    - konveyor.io/target=openshift
    - konveyor.io/target=kubernetes
    - konveyor.io/target=eks
  description: Exposure To Internet
  when:
    k8s-resource.rego_module:
        module: |-
            package policy

            # Checks if NodePort or LoadBalancer is connected to a workload to expose something
            deny[msga] {
                service := input[_]
                service.kind == "Service"
                is_exposed_service(service)

                wl := input[_]
                spec_template_spec_patterns := {"Deployment", "ReplicaSet", "DaemonSet", "StatefulSet", "Pod", "Job", "CronJob"}
                spec_template_spec_patterns[wl.kind]
                wl_connected_to_service(wl, service)
                failPath := ["spec.type"]
                msga := {
                    "alertMessage": sprintf("workload '%v' is exposed through service '%v'", [wl.metadata.name, service.metadata.name]),
                    "packagename": "policy",
                    "alertScore": 7,
                    "fixPaths": [],
                    "failedPaths": [],
                    "alertObject": {
                        "k8sApiObjects": [wl]
                    },
                    "relatedObjects": [{
                        "object": service,
            		    "reviewPaths": failPath,
                        "failedPaths": failPath,
                    }]
                }
            }

            # Checks if Ingress is connected to a service and a workload to expose something
            deny[msga] {
                ingress := input[_]
                ingress.kind == "Ingress"

                svc := input[_]
                svc.kind == "Service"

                # Make sure that they belong to the same namespace
                svc.metadata.namespace == ingress.metadata.namespace

                # avoid duplicate alerts
                # if service is already exposed through NodePort or LoadBalancer workload will fail on that
                not is_exposed_service(svc)

                wl := input[_]
                spec_template_spec_patterns := {"Deployment", "ReplicaSet", "DaemonSet", "StatefulSet", "Pod", "Job", "CronJob"}
                spec_template_spec_patterns[wl.kind]
                wl_connected_to_service(wl, svc)

                result := svc_connected_to_ingress(svc, ingress)

                msga := {
                    "alertMessage": sprintf("workload '%v' is exposed through ingress '%v'", [wl.metadata.name, ingress.metadata.name]),
                    "packagename": "policy",
                    "failedPaths": [],
                    "fixPaths": [],
                    "alertScore": 7,
                    "alertObject": {
                        "k8sApiObjects": [wl]
                    },
                    "relatedObjects": [
            		{
            	            "object": ingress,
            		    "reviewPaths": result,
            	            "failedPaths": result,
            	        },
            		{
            	            "object": svc,
            		}
                    ]
                }
            }

            # ====================================================================================

            is_exposed_service(svc) {
                svc.spec.type == "NodePort"
            }

            is_exposed_service(svc) {
                svc.spec.type == "LoadBalancer"
            }

            wl_connected_to_service(wl, svc) {
                count({x | svc.spec.selector[x] == wl.metadata.labels[x]}) == count(svc.spec.selector)
            }

            wl_connected_to_service(wl, svc) {
                wl.spec.selector.matchLabels == svc.spec.selector
            }

            # check if service is connected to ingress
            svc_connected_to_ingress(svc, ingress) = result {
                rule := ingress.spec.rules[i]
                paths := rule.http.paths[j]
                svc.metadata.name == paths.backend.service.name
                result := [sprintf("spec.rules[%d].http.paths[%d].backend.service.name", [i,j])]
            }


            incidents[msg] {
              violation := deny[_]
              apiObjects := object.get(violation.alertObject, "k8sApiObjects", false)
              item := apiObjects[_]
              msg := {
            	  "apiVersion": item.apiVersion,
            		"namespace": item.metadata.namespace,
            		"kind": item.kind,
            		"name": item.metadata.name,
              }
            }

            incidents[msg] {
              violation := deny[_]
              item := object.get(violation.alertObject, "externalObjects", false)
              msg := {
            	  "apiVersion": item.apiVersion,
            		"namespace": item.metadata.namespace,
            		"kind": item.kind,
            		"name": item.metadata.name,
              }
            }
        resources: []
        defaults: false
