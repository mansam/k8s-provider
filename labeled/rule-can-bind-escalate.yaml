- ruleID: rule_can_bind_escalate
  effort: 1
  category: optional
  message: determines which users can or bind escalate roles/clusterroles
  labels:
    - eks
    - kubernetes
    - kubescape
    - konveyor.io/target=openshift
    - konveyor.io/target=kubernetes
    - konveyor.io/target=eks
  description: Rule Can Bind Escalate
  when:
    k8s-resource.rego_module:
        module: |-
            package policy

            import future.keywords.in

            # ================= bind ===============================

            # fails if user has access to bind clusterroles/roles
            deny[msga] {
            	subjectVector := input[_]
            	role := subjectVector.relatedObjects[i]
            	rolebinding := subjectVector.relatedObjects[j]
            	endswith(role.kind, "Role")
            	endswith(rolebinding.kind, "Binding")
            	rule := role.rules[p]

            	subject := rolebinding.subjects[k]
            	is_same_subjects(subjectVector, subject)

            	rule_path := sprintf("relatedObjects[%d].rules[%d]", [i, p])

            	verbs := ["bind", "*"]
            	verb_path := [sprintf("%s.verbs[%d]", [rule_path, l]) | verb = rule.verbs[l]; verb in verbs]
            	count(verb_path) > 0

            	api_groups := ["rbac.authorization.k8s.io", "*"]
            	api_groups_path := [sprintf("%s.apiGroups[%d]", [rule_path, a]) | apiGroup = rule.apiGroups[a]; apiGroup in api_groups]
            	count(api_groups_path) > 0

            	resources := ["clusterroles", "roles", "*"]
            	resources_path := [sprintf("%s.resources[%d]", [rule_path, l]) | resource = rule.resources[l]; resource in resources]
            	count(resources_path) > 0

            	path := array.concat(resources_path, verb_path)
            	path2 := array.concat(path, api_groups_path)
            	finalpath := array.concat(path2, [
            		sprintf("relatedObjects[%d].subjects[%d]", [j, k]),
            		sprintf("relatedObjects[%d].roleRef.name", [j]),
            	])

            	msga := {
            		"alertMessage": sprintf("Subject: %s-%s can bind roles/clusterroles", [subjectVector.kind, subjectVector.name]),
            		"alertScore": 3,
            		"reviewPaths": finalpath,
            		"failedPaths": finalpath,
            		"fixPaths": [],
            		"packagename": "policy",
            		"alertObject": {
            			"k8sApiObjects": [],
            			"externalObjects": subjectVector,
            		},
            	}
            }

            # ================= escalate ===============================

            # fails if user has access to escalate roles/clusterroles
            deny[msga] {
            	subjectVector := input[_]
            	role := subjectVector.relatedObjects[i]
            	rolebinding := subjectVector.relatedObjects[j]
            	endswith(role.kind, "Role")
            	endswith(rolebinding.kind, "Binding")

            	rule := role.rules[p]

            	subject := rolebinding.subjects[k]
            	is_same_subjects(subjectVector, subject)

            	is_same_subjects(subjectVector, subject)
            	rule_path := sprintf("relatedObjects[%d].rules[%d]", [i, p])

            	verbs := ["escalate", "*"]
            	verb_path := [sprintf("%s.verbs[%d]", [rule_path, l]) | verb = rule.verbs[l]; verb in verbs]
            	count(verb_path) > 0

            	api_groups := ["rbac.authorization.k8s.io", "*"]
            	api_groups_path := [sprintf("%s.apiGroups[%d]", [rule_path, a]) | apiGroup = rule.apiGroups[a]; apiGroup in api_groups]
            	count(api_groups_path) > 0

            	resources := ["clusterroles", "roles", "*"]
            	resources_path := [sprintf("%s.resources[%d]", [rule_path, l]) | resource = rule.resources[l]; resource in resources]
            	count(resources_path) > 0

            	path := array.concat(resources_path, verb_path)
            	path2 := array.concat(path, api_groups_path)
            	finalpath := array.concat(path2, [
            		sprintf("relatedObjects[%d].subjects[%d]", [j, k]),
            		sprintf("relatedObjects[%d].roleRef.name", [j]),
            	])

            	msga := {
            		"alertMessage": sprintf("Subject: %s-%s can escalate roles/clusterroles", [subjectVector.kind, subjectVector.name]),
            		"alertScore": 3,
            		"reviewPaths": finalpath,
            		"failedPaths": finalpath,
            		"fixPaths": [],
            		"packagename": "policy",
            		"alertObject": {
            			"k8sApiObjects": [],
            			"externalObjects": subjectVector,
            		},
            	}
            }

            # for service accounts
            is_same_subjects(subjectVector, subject) {
            	subjectVector.kind == subject.kind
            	subjectVector.name == subject.name
            	subjectVector.namespace == subject.namespace
            }

            # for users/ groups
            is_same_subjects(subjectVector, subject) {
            	subjectVector.kind == subject.kind
            	subjectVector.name == subject.name
            	subjectVector.apiGroup == subject.apiGroup
            }

            incidents[msg] {
              violation := deny[_]
              apiObjects := object.get(violation.alertObject, "k8sApiObjects", false)
              item := apiObjects[_]
              msg := {
            	  "apiVersion": item.apiVersion,
            		"namespace": item.metadata.namespace,
            		"kind": item.kind,
            		"name": item.metadata.name,
              }
            }

            incidents[msg] {
              violation := deny[_]
              item := object.get(violation.alertObject, "externalObjects", false)
              msg := {
            	  "apiVersion": item.apiVersion,
            		"namespace": item.metadata.namespace,
            		"kind": item.kind,
            		"name": item.metadata.name,
              }
            }
        resources: []
        defaults: false
